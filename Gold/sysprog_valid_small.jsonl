{"instruction": "Briefly explain reliable signal handling with sigaction() vs signal(). Provide an example installing a SIGCHLD handler.", "input": "", "output": "sigaction() is preferred for predictable semantics, flags (SA_RESTART, SA_NOCLDWAIT), and mask control; signal() is older and less consistent across systems.\n\n```c\n#include <stdio.h>\n#include <signal.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\nint main(int argc, char **argv) {\n    void h(int s) { int st; while (waitpid(-1, &st, WNOHANG) > 0) { printf(\"child exit=%d\\n\", WEXITSTATUS(st)); } }\n    struct sigaction sa = {0}; sa.sa_handler = h; sigemptyset(&sa.sa_mask); sa.sa_flags = SA_RESTART; sigaction(SIGCHLD, &sa, NULL);\n    if (fork() == 0) { _exit(0); }\n    pause();\n}\n```"}
{"instruction": "strace shows repeated EAGAIN on recv(). What does it mean and what should you do?", "input": "", "output": "The socket is non-blocking and no data is available; wait for readability (epoll/select) and retry on EAGAIN."}
{"instruction": "Provide a C program that creates a pipe; parent writes a message; child reads and prints it.", "input": "", "output": "```c\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint main(int argc, char **argv) {\n    int fds[2]; if (pipe(fds) < 0) { perror(\"pipe\"); return 1; }\n    pid_t p = fork(); if (p < 0) { perror(\"fork\"); return 1; }\n    if (p == 0) { close(fds[1]); char buf[128]; ssize_t n = read(fds[0], buf, sizeof(buf)-1); if (n>0){ buf[n]='\\0'; printf(\"child: %s\\n\", buf);} return 0; }\n    close(fds[0]); const char *msg = \"hello from parent\"; write(fds[1], msg, strlen(msg)); close(fds[1]);\n    waitpid(p, NULL, 0);\n    return 0;\n}\n```"}
{"instruction": "Write a C program that spawns 4 POSIX threads; each increments a shared counter with a mutex.", "input": "", "output": "```c\n#include <stdio.h>\n#include <pthread.h>\n\nint main(int argc, char **argv) {\n    pthread_t th[4]; pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER; int counter = 0;\n    void* run(void* arg) { for (int i=0;i<100000;i++){ pthread_mutex_lock(&m); counter++; pthread_mutex_unlock(&m);} return NULL; }\n    for (int i=0;i<4;i++) pthread_create(&th[i], NULL, run, NULL);\n    for (int i=0;i<4;i++) pthread_join(th[i], NULL);\n    printf(\"counter=%d\\n\", counter);\n    return 0;\n}\n```"}
{"instruction": "Demonstrate pthread condition variables with a producer/consumer of a single-slot buffer.", "input": "", "output": "```c\n#include <stdio.h>\n#include <pthread.h>\n\npthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER; pthread_cond_t cv = PTHREAD_COND_INITIALIZER; int ready=0; int value=0;\nvoid* producer(void* arg){ pthread_mutex_lock(&m); value=42; ready=1; pthread_cond_signal(&cv); pthread_mutex_unlock(&m); return NULL; }\nvoid* consumer(void* arg){ pthread_mutex_lock(&m); while(!ready) pthread_cond_wait(&cv,&m); printf(\"got %d\\n\", value); pthread_mutex_unlock(&m); return NULL; }\nint main(){ pthread_t p,c; pthread_create(&p,NULL,producer,NULL); pthread_create(&c,NULL,consumer,NULL); pthread_join(p,NULL); pthread_join(c,NULL); return 0; }\n```"}
{"instruction": "Write a minimal TCP echo server in C using IPv4 and accept() one client.", "input": "", "output": "```c\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint main(int argc, char **argv) {\n    int s = socket(AF_INET, SOCK_STREAM, 0); if (s < 0) { perror(\"socket\"); return 1; }\n    struct sockaddr_in addr = {0}; addr.sin_family = AF_INET; addr.sin_addr.s_addr = htonl(INADDR_ANY); addr.sin_port = htons(9090);\n    int on=1; setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));\n    if (bind(s, (struct sockaddr*)&addr, sizeof(addr)) < 0) { perror(\"bind\"); return 1; }\n    if (listen(s, 1) < 0) { perror(\"listen\"); return 1; }\n    int c = accept(s, NULL, NULL); if (c < 0) { perror(\"accept\"); return 1; }\n    char b[1024]; ssize_t n; while ((n = recv(c, b, sizeof(b), 0)) > 0) { send(c, b, n, 0); }\n    close(c); close(s);\n    return 0;\n}\n```"}
{"instruction": "Demonstrate using mmap() for a file-backed mapping and print the first 64 bytes.", "input": "", "output": "```c\n#include <stdio.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n\nint main(int argc, char **argv) {\n    int fd = open(\"/etc/hosts\", O_RDONLY); if (fd < 0) { perror(\"open\"); return 1; }\n    off_t sz = lseek(fd, 0, SEEK_END); lseek(fd, 0, SEEK_SET);\n    char *p = mmap(NULL, sz, PROT_READ, MAP_PRIVATE, fd, 0);\n    if (p == MAP_FAILED) { perror(\"mmap\"); return 1; }\n    for (size_t i=0; i<64 && i<(size_t)sz; i++) putchar(p[i]); putchar('\\n');\n    munmap(p, sz); close(fd);\n    return 0;\n}\n```"}
{"instruction": "Provide a C program that creates a child with fork(), waits for it, and prints both PIDs.", "input": "", "output": "```c\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\nint main(int argc, char **argv) {\n    pid_t pid = fork();\n    if (pid < 0) { perror(\"fork\"); return 1; }\n    if (pid == 0) { printf(\"child pid=%d\\n\", getpid()); return 0; }\n    int st = 0; waitpid(pid, &st, 0);\n    printf(\"parent pid=%d, child=%d, status=%d\\n\", getpid(), pid, WEXITSTATUS(st));\n    return 0;\n}\n```"}
{"instruction": "Show pthread condition variables with a producer/consumer of a single-slot buffer.", "input": "", "output": "```c\n#include <stdio.h>\n#include <pthread.h>\n\npthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER; pthread_cond_t cv = PTHREAD_COND_INITIALIZER; int ready=0; int value=0;\nvoid* producer(void* arg){ pthread_mutex_lock(&m); value=42; ready=1; pthread_cond_signal(&cv); pthread_mutex_unlock(&m); return NULL; }\nvoid* consumer(void* arg){ pthread_mutex_lock(&m); while(!ready) pthread_cond_wait(&cv,&m); printf(\"got %d\\n\", value); pthread_mutex_unlock(&m); return NULL; }\nint main(){ pthread_t p,c; pthread_create(&p,NULL,producer,NULL); pthread_create(&c,NULL,consumer,NULL); pthread_join(p,NULL); pthread_join(c,NULL); return 0; }\n```"}
{"instruction": "Create and use POSIX shared memory with shm_open + mmap. Write from one process and read from another.", "input": "", "output": "```c\n#include <stdio.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <sys/wait.h>\n\nint main(int argc, char **argv) {\n    const char *name = \"/demo_shm\"; int fd = shm_open(name, O_CREAT|O_RDWR, 0600);\n    if (fd < 0) { perror(\"shm_open\"); return 1; }\n    size_t sz = 4096; if (ftruncate(fd, sz) < 0) { perror(\"ftruncate\"); return 1; }\n    char *p = mmap(NULL, sz, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n    if (p == MAP_FAILED) { perror(\"mmap\"); return 1; }\n    pid_t c = fork(); if (c == 0) { strcpy(p, \"hello shm\"); _exit(0);} waitpid(c, NULL, 0);\n    printf(\"parent sees: %s\\n\", p);\n    munmap(p, sz); close(fd); shm_unlink(name);\n    return 0;\n}\n```"}
{"instruction": "Provide a C program that spawns 4 POSIX threads; each increments a shared counter with a mutex.", "input": "", "output": "```c\n#include <stdio.h>\n#include <pthread.h>\n\nint main(int argc, char **argv) {\n    pthread_t th[4]; pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER; int counter = 0;\n    void* run(void* arg) { for (int i=0;i<100000;i++){ pthread_mutex_lock(&m); counter++; pthread_mutex_unlock(&m);} return NULL; }\n    for (int i=0;i<4;i++) pthread_create(&th[i], NULL, run, NULL);\n    for (int i=0;i<4;i++) pthread_join(th[i], NULL);\n    printf(\"counter=%d\\n\", counter);\n    return 0;\n}\n```"}
{"instruction": "Why can select() fail for fd>1024 without recompiling?", "input": "", "output": "FD_SETSIZE is typically 1024; exceeding it is undefined unless you rebuild with a larger size."}
{"instruction": "Write a minimal C snippet that demonstrates the POSIX open() usage with proper error handling.", "input": "", "output": "```c\n#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/mman.h>\n\nint main(int argc, char **argv) {\n    int fd=open(\"/tmp/demo.txt\", O_CREAT|O_WRONLY, 0644); if(fd<0){perror(\"open\");return 1;} write(fd, \"hi\\n\", 3); close(fd);\n    return 0;\n}\n```"}
{"instruction": "Provide a minimal TCP echo server in C using IPv4 and accept() one client.", "input": "", "output": "```c\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint main(int argc, char **argv) {\n    int s = socket(AF_INET, SOCK_STREAM, 0); if (s < 0) { perror(\"socket\"); return 1; }\n    struct sockaddr_in addr = {0}; addr.sin_family = AF_INET; addr.sin_addr.s_addr = htonl(INADDR_ANY); addr.sin_port = htons(9090);\n    int on=1; setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));\n    if (bind(s, (struct sockaddr*)&addr, sizeof(addr)) < 0) { perror(\"bind\"); return 1; }\n    if (listen(s, 1) < 0) { perror(\"listen\"); return 1; }\n    int c = accept(s, NULL, NULL); if (c < 0) { perror(\"accept\"); return 1; }\n    char b[1024]; ssize_t n; while ((n = recv(c, b, sizeof(b), 0)) > 0) { send(c, b, n, 0); }\n    close(c); close(s);\n    return 0;\n}\n```"}
{"instruction": "Write a C program that launches 4 threads and increments a shared counter safely using a mutex.", "input": "", "output": "```c\n#include <stdio.h>\n#include <pthread.h>\n\nint main(int argc, char **argv) {\n    pthread_t th[4]; pthread_mutex_t m=PTHREAD_MUTEX_INITIALIZER; long counter=0;\n    void* run(void*arg){ for(long i=0;i<200000;i++){ pthread_mutex_lock(&m); counter++; pthread_mutex_unlock(&m);} return NULL; }\n    for(int i=0;i<4;i++) pthread_create(&th[i],NULL,run,NULL);\n    for(int i=0;i<4;i++) pthread_join(th[i],NULL);\n    printf(\"counter=%ld\\n\", counter);\n    return 0;\n}\n```"}
{"instruction": "Write a C program that creates a pipe; parent writes a message; child reads and prints it.", "input": "", "output": "```c\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint main(int argc, char **argv) {\n    int fds[2]; if (pipe(fds) < 0) { perror(\"pipe\"); return 1; }\n    pid_t p = fork(); if (p < 0) { perror(\"fork\"); return 1; }\n    if (p == 0) { close(fds[1]); char buf[128]; ssize_t n = read(fds[0], buf, sizeof(buf)-1); if (n>0){ buf[n]='\\0'; printf(\"child: %s\\n\", buf);} return 0; }\n    close(fds[0]); const char *msg = \"hello from parent\"; write(fds[1], msg, strlen(msg)); close(fds[1]);\n    waitpid(p, NULL, 0);\n    return 0;\n}\n```"}
{"instruction": "Provide a minimal C snippet that demonstrates the POSIX open() usage with proper error handling.", "input": "", "output": "```c\n#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/mman.h>\n\nint main(int argc, char **argv) {\n    int fd=open(\"/tmp/demo.txt\", O_CREAT|O_WRONLY, 0644); if(fd<0){perror(\"open\");return 1;} write(fd, \"hi\\n\", 3); close(fd);\n    return 0;\n}\n```"}
{"instruction": "Write a minimal C snippet that demonstrates the POSIX mmap() usage with proper error handling.", "input": "", "output": "```c\n#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/mman.h>\n\nint main(int argc, char **argv) {\n    int fd=open(\"/etc/hosts\",O_RDONLY); off_t sz=lseek(fd,0,SEEK_END); lseek(fd,0,SEEK_SET); char* p=mmap(NULL,sz,PROT_READ,MAP_PRIVATE,fd,0); if(p!=MAP_FAILED) write(1,p, sz>64?64:sz); munmap(p,sz); close(fd);\n    return 0;\n}\n```"}
{"instruction": "Create a timerfd that ticks once per second and prints a counter for 5 ticks.", "input": "", "output": "```c\n#include <stdio.h>\n#include <sys/timerfd.h>\n#include <unistd.h>\n#include <stdint.h>\n\nint main(int argc, char **argv) {\n    int t = timerfd_create(CLOCK_MONOTONIC, 0); if (t < 0) { perror(\"timerfd_create\"); return 1; }\n    struct itimerspec its = {{1,0}, {1,0}}; timerfd_settime(t, 0, &its, NULL);\n    for (int i=1;i<=5;i++){ uint64_t exp; read(t,&exp,sizeof(exp)); printf(\"tick %d\\n\", i); }\n    close(t); return 0;\n}\n```"}
{"instruction": "When is epoll edge-triggered mode preferable over level-triggered?", "input": "", "output": "Edge-triggered reduces wakeups for high-volume readiness; you must drain the socket until EAGAIN."}
