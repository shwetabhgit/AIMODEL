{"instruction": "Show how to watch /var/tmp for IN_CREATE using inotify and print created filenames.", "input": "", "output": "```c\n#include <stdio.h>\n#include <sys/inotify.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <string.h>\n#include <time.h>\n\nint main(int argc, char **argv) {\n    int fd=inotify_init1(IN_NONBLOCK); if(fd<0){perror(\"inotify_init1\");return 1;} int wd=inotify_add_watch(fd, \"/var/tmp\", IN_CREATE);\n    if(wd<0){perror(\"inotify_add_watch\");return 1;} char buf[4096] __attribute__((aligned(__alignof__(struct inotify_event))));\n    for(int i=0;i<3;i++){ ssize_t len=read(fd,buf,sizeof(buf)); if(len>0){ size_t off=0; while(off<len){ struct inotify_event*ev=(struct inotify_event*)(buf+off); if(ev->mask&IN_CREATE) printf(\"created: %s\\n\", ev->name); off+=sizeof(*ev)+ev->len; } } sleep(1);} \n    inotify_rm_watch(fd,wd); close(fd); return 0;\n}\n```"}
{"instruction": "Explain the difference between select(), poll(), and epoll() and when to use each on Linux.", "input": "", "output": "select() uses fixed-size fd-sets and scales poorly; poll() removes the fixed set limit but still scans O(n). epoll() maintains readiness sets and scales better for many fds; use epoll for high concurrency."}
{"instruction": "Write a minimal C snippet that demonstrates the POSIX stat() usage with proper error handling.", "input": "", "output": "```c\n#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/mman.h>\n\nint main(int argc, char **argv) {\n    struct stat st; if(stat(\"/etc/hosts\", &st)<0){perror(\"stat\");return 1;} printf(\"size=%ld\\n\", (long)st.st_size);\n    return 0;\n}\n```"}
{"instruction": "Write a C program that launches 2 threads and increments a shared counter safely using a mutex.", "input": "", "output": "```c\n#include <stdio.h>\n#include <pthread.h>\n\nint main(int argc, char **argv) {\n    pthread_t th[2]; pthread_mutex_t m=PTHREAD_MUTEX_INITIALIZER; long counter=0;\n    void* run(void*arg){ for(long i=0;i<200000;i++){ pthread_mutex_lock(&m); counter++; pthread_mutex_unlock(&m);} return NULL; }\n    for(int i=0;i<2;i++) pthread_create(&th[i],NULL,run,NULL);\n    for(int i=0;i<2;i++) pthread_join(th[i],NULL);\n    printf(\"counter=%ld\\n\", counter);\n    return 0;\n}\n```"}
{"instruction": "Provide a minimal C snippet that demonstrates the POSIX read() usage with proper error handling.", "input": "", "output": "```c\n#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/mman.h>\n\nint main(int argc, char **argv) {\n    int fd=open(\"/etc/hosts\", O_RDONLY); if(fd<0){perror(\"open\");return 1;} char b[256]; ssize_t n=read(fd,b,sizeof(b)); if(n>0) write(1,b,n); close(fd);\n    return 0;\n}\n```"}
{"instruction": "Write a C program that creates a child with fork(), waits for it, and prints both PIDs.", "input": "", "output": "```c\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\nint main(int argc, char **argv) {\n    pid_t pid = fork();\n    if (pid < 0) { perror(\"fork\"); return 1; }\n    if (pid == 0) { printf(\"child pid=%d\\n\", getpid()); return 0; }\n    int st = 0; waitpid(pid, &st, 0);\n    printf(\"parent pid=%d, child=%d, status=%d\\n\", getpid(), pid, WEXITSTATUS(st));\n    return 0;\n}\n```"}
{"instruction": "Use inotify to watch /tmp for IN_CREATE events and print created names.", "input": "", "output": "```c\n#include <stdio.h>\n#include <sys/inotify.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <string.h>\n#include <time.h>\n\nint main(int argc, char **argv) {\n    int fd = inotify_init1(IN_NONBLOCK); if (fd < 0) { perror(\"inotify_init1\"); return 1; }\n    int wd = inotify_add_watch(fd, \"/tmp\", IN_CREATE); if (wd < 0) { perror(\"inotify_add_watch\"); return 1; }\n    char buf[4096] __attribute__((aligned(__alignof__(struct inotify_event))));\n    for (int i=0;i<5;i++) {\n        ssize_t len = read(fd, buf, sizeof(buf));\n        if (len > 0) {\n            size_t off = 0; while (off < (size_t)len) {\n                struct inotify_event *ev = (struct inotify_event*)(buf+off);\n                if (ev->mask & IN_CREATE) printf(\"created: %s\\n\", ev->name);\n                off += sizeof(*ev) + ev->len;\n            }\n        }\n        sleep(1);\n    }\n    inotify_rm_watch(fd, wd); close(fd); return 0;\n}\n```"}
{"instruction": "Write a minimal C snippet that demonstrates the POSIX read() usage with proper error handling.", "input": "", "output": "```c\n#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/mman.h>\n\nint main(int argc, char **argv) {\n    int fd=open(\"/etc/hosts\", O_RDONLY); if(fd<0){perror(\"open\");return 1;} char b[256]; ssize_t n=read(fd,b,sizeof(b)); if(n>0) write(1,b,n); close(fd);\n    return 0;\n}\n```"}
{"instruction": "Show how to watch /tmp for IN_CREATE using inotify and print created filenames.", "input": "", "output": "```c\n#include <stdio.h>\n#include <sys/inotify.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <string.h>\n#include <time.h>\n\nint main(int argc, char **argv) {\n    int fd=inotify_init1(IN_NONBLOCK); if(fd<0){perror(\"inotify_init1\");return 1;} int wd=inotify_add_watch(fd, \"/tmp\", IN_CREATE);\n    if(wd<0){perror(\"inotify_add_watch\");return 1;} char buf[4096] __attribute__((aligned(__alignof__(struct inotify_event))));\n    for(int i=0;i<3;i++){ ssize_t len=read(fd,buf,sizeof(buf)); if(len>0){ size_t off=0; while(off<len){ struct inotify_event*ev=(struct inotify_event*)(buf+off); if(ev->mask&IN_CREATE) printf(\"created: %s\\n\", ev->name); off+=sizeof(*ev)+ev->len; } } sleep(1);} \n    inotify_rm_watch(fd,wd); close(fd); return 0;\n}\n```"}
{"instruction": "Explain the difference between fork() and vfork() with concise rationale and a micro example.", "input": "", "output": "fork() duplicates the process using copy-on-write; parent and child run independently. vfork() runs the child first while sharing the parent's address space until exec/exit; the parent is suspended to avoid undefined behavior.\n\n```c\n#include <unistd.h>\n\nint main(int argc, char **argv) {\n    pid_t p = vfork(); if (p == 0) { _exit(0); } return 0;\n}\n```"}
{"instruction": "Write a C function that reads a file and prints it to stdout using POSIX read() in a loop.", "input": "", "output": "```c\n#define _XOPEN_SOURCE 700\n#include <unistd.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <errno.h>\n#include <string.h>\n\nvoid print_file(const char *path) {\n    int fd = open(path, O_RDONLY);\n    if (fd < 0) { perror(\"open\"); return; }\n    char buf[4096]; ssize_t n;\n    while ((n = read(fd, buf, sizeof(buf))) > 0) {\n        if (write(STDOUT_FILENO, buf, n) < 0) { perror(\"write\"); break; }\n    }\n    if (n < 0) perror(\"read\");\n    if (close(fd) < 0) perror(\"close\");\n}\n```"}
{"instruction": "gdb backtrace points to free() after double free detected. Explain and suggest mitigation.", "input": "", "output": "Double free corrupts the heap. Free each allocation exactly once, set pointers to NULL after free, and consider ASan/valgrind."}
{"instruction": "Provide a minimal TCP server in C that listens on port 8080 and echoes one line.", "input": "", "output": "```c\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint main(int argc, char **argv) {\n    int s=socket(AF_INET,SOCK_STREAM,0); if(s<0){perror(\"socket\");return 1;}\n    struct sockaddr_in a={0}; a.sin_family=AF_INET; a.sin_addr.s_addr=htonl(INADDR_ANY); a.sin_port=htons(8080);\n    int on=1; setsockopt(s,SOL_SOCKET,SO_REUSEADDR,&on,sizeof(on));\n    if(bind(s,(struct sockaddr*)&a,sizeof(a))<0){perror(\"bind\");return 1;} listen(s,1);\n    int c=accept(s,NULL,NULL); if(c<0){perror(\"accept\");return 1;} char b[256]; ssize_t n=read(c,b,sizeof(b)); if(n>0) write(c,b,n);\n    close(c); close(s); return 0;\n}\n```"}
{"instruction": "Write a C program that installs a SIGINT handler, counts signals, and exits after 3 Ctrl-C presses.", "input": "", "output": "```c\n#include <stdio.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nint main(int argc, char **argv) {\n    static volatile sig_atomic_t cnt = 0;\n    void h(int s) { cnt++; printf(\"SIGINT %d\\n\", cnt); if (cnt >= 3) _exit(0); }\n    struct sigaction sa = {0}; sa.sa_handler = h; sigemptyset(&sa.sa_mask); sa.sa_flags = SA_RESTART;\n    if (sigaction(SIGINT, &sa, NULL) < 0) { perror(\"sigaction\"); return 1; }\n    printf(\"press Ctrl-C up to 3 times\\n\");\n    for (;;) pause();\n}\n```"}
{"instruction": "Write a C program that launches 8 threads and increments a shared counter safely using a mutex.", "input": "", "output": "```c\n#include <stdio.h>\n#include <pthread.h>\n\nint main(int argc, char **argv) {\n    pthread_t th[8]; pthread_mutex_t m=PTHREAD_MUTEX_INITIALIZER; long counter=0;\n    void* run(void*arg){ for(long i=0;i<200000;i++){ pthread_mutex_lock(&m); counter++; pthread_mutex_unlock(&m);} return NULL; }\n    for(int i=0;i<8;i++) pthread_create(&th[i],NULL,run,NULL);\n    for(int i=0;i<8;i++) pthread_join(th[i],NULL);\n    printf(\"counter=%ld\\n\", counter);\n    return 0;\n}\n```"}
{"instruction": "Provide a minimal TCP server in C that listens on port 10000 and echoes one line.", "input": "", "output": "```c\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint main(int argc, char **argv) {\n    int s=socket(AF_INET,SOCK_STREAM,0); if(s<0){perror(\"socket\");return 1;}\n    struct sockaddr_in a={0}; a.sin_family=AF_INET; a.sin_addr.s_addr=htonl(INADDR_ANY); a.sin_port=htons(10000);\n    int on=1; setsockopt(s,SOL_SOCKET,SO_REUSEADDR,&on,sizeof(on));\n    if(bind(s,(struct sockaddr*)&a,sizeof(a))<0){perror(\"bind\");return 1;} listen(s,1);\n    int c=accept(s,NULL,NULL); if(c<0){perror(\"accept\");return 1;} char b[256]; ssize_t n=read(c,b,sizeof(b)); if(n>0) write(c,b,n);\n    close(c); close(s); return 0;\n}\n```"}
{"instruction": "Provide a minimal C snippet that demonstrates the POSIX stat() usage with proper error handling.", "input": "", "output": "```c\n#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/mman.h>\n\nint main(int argc, char **argv) {\n    struct stat st; if(stat(\"/etc/hosts\", &st)<0){perror(\"stat\");return 1;} printf(\"size=%ld\\n\", (long)st.st_size);\n    return 0;\n}\n```"}
{"instruction": "strace shows `openat(AT_FDCWD, \"missing.txt\", O_RDONLY) = -1 ENOENT`. Explain and suggest a fix.", "input": "", "output": "The path does not exist. Create the file, correct the path, or handle ENOENT with a clear error message."}
{"instruction": "Explain reliable signal handling with sigaction() vs signal(). Provide an example installing a SIGCHLD handler.", "input": "", "output": "sigaction() is preferred for predictable semantics, flags (SA_RESTART, SA_NOCLDWAIT), and mask control; signal() is older and less consistent across systems.\n\n```c\n#include <stdio.h>\n#include <signal.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\nint main(int argc, char **argv) {\n    void h(int s) { int st; while (waitpid(-1, &st, WNOHANG) > 0) { printf(\"child exit=%d\\n\", WEXITSTATUS(st)); } }\n    struct sigaction sa = {0}; sa.sa_handler = h; sigemptyset(&sa.sa_mask); sa.sa_flags = SA_RESTART; sigaction(SIGCHLD, &sa, NULL);\n    if (fork() == 0) { _exit(0); }\n    pause();\n}\n```"}
{"instruction": "Create a timerfd that ticks once per second and prints a counter for 5 ticks.", "input": "", "output": "```c\n#include <stdio.h>\n#include <sys/timerfd.h>\n#include <unistd.h>\n#include <stdint.h>\n\nint main(int argc, char **argv) {\n    int t = timerfd_create(CLOCK_MONOTONIC, 0); if (t < 0) { perror(\"timerfd_create\"); return 1; }\n    struct itimerspec its = {{1,0}, {1,0}}; timerfd_settime(t, 0, &its, NULL);\n    for (int i=1;i<=5;i++){ uint64_t exp; read(t,&exp,sizeof(exp)); printf(\"tick %d\\n\", i); }\n    close(t); return 0;\n}\n```"}
{"instruction": "Show using mmap() for a file-backed mapping and print the first 64 bytes.", "input": "", "output": "```c\n#include <stdio.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n\nint main(int argc, char **argv) {\n    int fd = open(\"/etc/hosts\", O_RDONLY); if (fd < 0) { perror(\"open\"); return 1; }\n    off_t sz = lseek(fd, 0, SEEK_END); lseek(fd, 0, SEEK_SET);\n    char *p = mmap(NULL, sz, PROT_READ, MAP_PRIVATE, fd, 0);\n    if (p == MAP_FAILED) { perror(\"mmap\"); return 1; }\n    for (size_t i=0; i<64 && i<(size_t)sz; i++) putchar(p[i]); putchar('\\n');\n    munmap(p, sz); close(fd);\n    return 0;\n}\n```"}
{"instruction": "Write a minimal C snippet that demonstrates the POSIX dup2() usage with proper error handling.", "input": "", "output": "```c\n#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/mman.h>\n\nint main(int argc, char **argv) {\n    int fd=open(\"/tmp/log.txt\", O_CREAT|O_WRONLY|O_TRUNC, 0644); dup2(fd,1); printf(\"to file\\n\"); close(fd);\n    return 0;\n}\n```"}
{"instruction": "Provide a minimal TCP server in C that listens on port 9090 and echoes one line.", "input": "", "output": "```c\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint main(int argc, char **argv) {\n    int s=socket(AF_INET,SOCK_STREAM,0); if(s<0){perror(\"socket\");return 1;}\n    struct sockaddr_in a={0}; a.sin_family=AF_INET; a.sin_addr.s_addr=htonl(INADDR_ANY); a.sin_port=htons(9090);\n    int on=1; setsockopt(s,SOL_SOCKET,SO_REUSEADDR,&on,sizeof(on));\n    if(bind(s,(struct sockaddr*)&a,sizeof(a))<0){perror(\"bind\");return 1;} listen(s,1);\n    int c=accept(s,NULL,NULL); if(c<0){perror(\"accept\");return 1;} char b[256]; ssize_t n=read(c,b,sizeof(b)); if(n>0) write(c,b,n);\n    close(c); close(s); return 0;\n}\n```"}
{"instruction": "Given the code `int *p=NULL; *p=42;` explain the crash and provide a safe fix.", "input": "", "output": "Dereferencing a NULL pointer causes a segmentation fault. Allocate memory or use a valid object before dereferencing.\n\n```c\nint *p = malloc(sizeof *p);\nif (!p) { perror(\"malloc\"); exit(1);} *p = 42; free(p);\n```"}
{"instruction": "Provide a minimal TCP server in C that listens on port 10000 and echoes one line.", "input": "", "output": "```c\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint main(int argc, char **argv) {\n    int s=socket(AF_INET,SOCK_STREAM,0); if(s<0){perror(\"socket\");return 1;}\n    struct sockaddr_in a={0}; a.sin_family=AF_INET; a.sin_addr.s_addr=htonl(INADDR_ANY); a.sin_port=htons(10000);\n    int on=1; setsockopt(s,SOL_SOCKET,SO_REUSEADDR,&on,sizeof(on));\n    if(bind(s,(struct sockaddr*)&a,sizeof(a))<0){perror(\"bind\");return 1;} listen(s,1);\n    int c=accept(s,NULL,NULL); if(c<0){perror(\"accept\");return 1;} char b[256]; ssize_t n=read(c,b,sizeof(b)); if(n>0) write(c,b,n);\n    close(c); close(s); return 0;\n}\n```"}
